// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * DS209: Avoid top-level return
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
if (typeof require === 'undefined' || require === null) { return; }
const {buildCSOptionParser} = require('../lib/coffeescript/command');

const optionParser = buildCSOptionParser();

const sameOptions = function(opts1, opts2, msg) {
  const ownKeys = Object.keys(opts1).sort();
  const otherKeys = Object.keys(opts2).sort();
  arrayEq(ownKeys, otherKeys, msg);
  for (let k of Array.from(ownKeys)) {
    arrayEq(opts1[k], opts2[k], msg);
  }
  return true;
};

test("combined options are not split after initial file name", function() {
  let argv = ['some-file.coffee', '-bc'];
  let parsed = optionParser.parse(argv);
  let expected = {arguments: ['some-file.coffee', '-bc']};
  sameOptions(parsed, expected);

  argv = ['some-file.litcoffee', '-bc'];
  parsed = optionParser.parse(argv);
  expected = {arguments: ['some-file.litcoffee', '-bc']};
  sameOptions(parsed, expected);

  argv = ['-c', 'some-file.coffee', '-bc'];
  parsed = optionParser.parse(argv);
  expected = {
    compile: true,
    arguments: ['some-file.coffee', '-bc']
  };
  sameOptions(parsed, expected);

  argv = ['-bc', 'some-file.coffee', '-bc'];
  parsed = optionParser.parse(argv);
  expected = {
    bare: true,
    compile: true,
    arguments: ['some-file.coffee', '-bc']
  };
  return sameOptions(parsed, expected);
});

test("combined options are not split after a '--', which is discarded", function() {
  let argv = ['--', '-bc'];
  let parsed = optionParser.parse(argv);
  let expected = {
    doubleDashed: true,
    arguments: ['-bc']
  };
  sameOptions(parsed, expected);

  argv = ['-bc', '--', '-bc'];
  parsed = optionParser.parse(argv);
  expected = {
    bare: true,
    compile: true,
    doubleDashed: true,
    arguments: ['-bc']
  };
  return sameOptions(parsed, expected);
});

test("options are not split after any '--'", function() {
  let argv = ['--', '--', '-bc'];
  let parsed = optionParser.parse(argv);
  let expected = {
    doubleDashed: true,
    arguments: ['--', '-bc']
  };
  sameOptions(parsed, expected);

  argv = ['--', 'some-file.coffee', '--', 'arg'];
  parsed = optionParser.parse(argv);
  expected = {
    doubleDashed: true,
    arguments: ['some-file.coffee', '--', 'arg']
  };
  sameOptions(parsed, expected);

  argv = ['--', 'arg', 'some-file.coffee', '--', '-bc'];
  parsed = optionParser.parse(argv);
  expected = {
    doubleDashed: true,
    arguments: ['arg', 'some-file.coffee', '--', '-bc']
  };
  return sameOptions(parsed, expected);
});

test("any non-option argument stops argument parsing", function() {
  const argv = ['arg', '-bc'];
  const parsed = optionParser.parse(argv);
  const expected = {arguments: ['arg', '-bc']};
  return sameOptions(parsed, expected);
});

test("later '--' are not removed", function() {
  const argv = ['some-file.coffee', '--', '-bc'];
  const parsed = optionParser.parse(argv);
  const expected = {arguments: ['some-file.coffee', '--', '-bc']};
  return sameOptions(parsed, expected);
});

test("throw on invalid options", function() {
  let argv = ['-k'];
  throws(() => optionParser.parse(argv));

  argv = ['-ck'];
  throws((() => optionParser.parse(argv)), /multi-flag/);

  argv = ['-kc'];
  throws((() => optionParser.parse(argv)), /multi-flag/);

  argv = ['-oc'];
  throws((() => optionParser.parse(argv)), /needs an argument/);

  argv = ['-o'];
  throws((() => optionParser.parse(argv)), /value required/);

  argv = ['-co'];
  throws((() => optionParser.parse(argv)), /value required/);

  // Check if all flags in a multi-flag are recognized before checking if flags
  // before the last need arguments.
  argv = ['-ok'];
  return throws((() => optionParser.parse(argv)), /unrecognized option/);
});

test("has expected help text", () => ok(optionParser.help() === `\

Usage: coffee [options] path/to/script.coffee [args]

If called without options, \`coffee\` will run your script.

-b, --bare         compile without a top-level function wrapper
-c, --compile      compile to JavaScript and save as .js files
-e, --eval         pass a string from the command line as input
-h, --help         display this help message
-i, --interactive  run an interactive CoffeeScript REPL
-j, --join         concatenate the source CoffeeScript before compiling
-m, --map          generate source map and save as .js.map files
-M, --inline-map   generate source map and include it directly in output
-n, --nodes        print out the parse tree that the parser produces
  --nodejs       pass options directly to the "node" binary
  --no-header    suppress the "Generated by" header
-o, --output       set the output path or path/filename for compiled JavaScript
-p, --print        print out the compiled JavaScript
-r, --require      require the given module before eval or REPL
-s, --stdio        listen for and compile scripts over stdio
-l, --literate     treat stdio as literate style coffeescript
-t, --transpile    pipe generated JavaScript through Babel
  --tokens       print out the tokens that the lexer/rewriter produce
-v, --version      display the version number
-w, --watch        watch scripts for changes and rerun commands
\
`
));
