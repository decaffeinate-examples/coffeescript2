/* eslint-disable
    consistent-return,
    func-names,
    global-require,
    import/no-extraneous-dependencies,
    max-len,
    no-bitwise,
    no-cond-assign,
    no-console,
    no-multi-assign,
    no-nested-ternary,
    no-param-reassign,
    no-restricted-syntax,
    no-return-assign,
    no-shadow,
    no-unused-vars,
    no-use-before-define,
    no-var,
    vars-on-top,
*/
// TODO: This file was created by bulk-decaffeinate.
// Fix any style issues and re-enable lint.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// The `coffee` utility. Handles command-line compilation of CoffeeScript
// into various forms: saved into `.js` files or printed to stdout
// or recompiled every time the source is saved,
// printed as a token stream or as the syntax tree, or launch an
// interactive REPL.

// External dependencies.
let buildCSOptionParser;
const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const { EventEmitter } = require('events');
const helpers = require('./helpers');
const optparse = require('./optparse');
const CoffeeScript = require('./');

const useWinPathSep = path.sep === '\\';

// Allow CoffeeScript to emit Node.js events.
helpers.extend(CoffeeScript, new EventEmitter());

const printLine = (line) => process.stdout.write(`${line}\n`);
const printWarn = (line) => process.stderr.write(`${line}\n`);

const hidden = (file) => /^\.|~$/.test(file);

// The help banner that is printed in conjunction with `-h`/`--help`.
const BANNER = `\
Usage: coffee [options] path/to/script.coffee [args]

If called without options, \`coffee\` will run your script.\
`;

// The list of all the valid option flags that `coffee` knows how to handle.
const SWITCHES = [
  ['-b', '--bare', 'compile without a top-level function wrapper'],
  ['-c', '--compile', 'compile to JavaScript and save as .js files'],
  ['-e', '--eval', 'pass a string from the command line as input'],
  ['-h', '--help', 'display this help message'],
  ['-i', '--interactive', 'run an interactive CoffeeScript REPL'],
  ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'],
  ['-m', '--map', 'generate source map and save as .js.map files'],
  ['-M', '--inline-map', 'generate source map and include it directly in output'],
  ['-n', '--nodes', 'print out the parse tree that the parser produces'],
  ['--nodejs [ARGS]', 'pass options directly to the "node" binary'],
  ['--no-header', 'suppress the "Generated by" header'],
  ['-o', '--output [PATH]', 'set the output path or path/filename for compiled JavaScript'],
  ['-p', '--print', 'print out the compiled JavaScript'],
  ['-r', '--require [MODULE*]', 'require the given module before eval or REPL'],
  ['-s', '--stdio', 'listen for and compile scripts over stdio'],
  ['-l', '--literate', 'treat stdio as literate style coffeescript'],
  ['-t', '--transpile', 'pipe generated JavaScript through Babel'],
  ['--tokens', 'print out the tokens that the lexer/rewriter produce'],
  ['-v', '--version', 'display the version number'],
  ['-w', '--watch', 'watch scripts for changes and rerun commands'],
];

// Top-level objects shared by all the functions.
let opts = {};
const sources = [];
const sourceCode = [];
const notSources = {};
const watchedDirs = {};
let optionParser = null;

exports.buildCSOptionParser = (buildCSOptionParser = () => new optparse.OptionParser(SWITCHES, BANNER));

// Run `coffee` by parsing passed options and determining what action to take.
// Many flags cause us to divert before compiling anything. Flags passed after
// `--` will be passed verbatim to your script as arguments in `process.argv`
exports.run = function () {
  optionParser = buildCSOptionParser();
  try { parseOptions(); } catch (err) {
    console.error(`option parsing error: ${err.message}`);
    process.exit(1);
  }

  if ((!opts.doubleDashed) && (opts.arguments[1] === '--')) {
    printWarn(`\
coffee was invoked with '--' as the second positional argument, which is
now deprecated. To pass '--' as an argument to a script to run, put an
additional '--' before the path to your script.

'--' will be removed from the argument list.\
`);
    printWarn(`The positional arguments were: ${JSON.stringify(opts.arguments)}`);
    opts.arguments = [opts.arguments[0]].concat(opts.arguments.slice(2));
  }

  // Make the REPL *CLI* use the global context so as to (a) be consistent with the
  // `node` REPL CLI and, therefore, (b) make packages that modify native prototypes
  // (such as 'colors' and 'sugar') work as expected.
  const replCliOpts = { useGlobal: true };
  if (opts.require) { opts.prelude = makePrelude(opts.require); }
  replCliOpts.prelude = opts.prelude;
  replCliOpts.transpile = opts.transpile;
  if (opts.nodejs) { return forkNode(); }
  if (opts.help) { return usage(); }
  if (opts.version) { return version(); }
  if (opts.interactive) { return require('./repl').start(replCliOpts); }
  if (opts.stdio) { return compileStdio(); }
  if (opts.eval) { return compileScript(null, opts.arguments[0]); }
  if (!opts.arguments.length) { return require('./repl').start(replCliOpts); }
  const literals = opts.run ? opts.arguments.splice(1) : [];
  process.argv = process.argv.slice(0, 2).concat(literals);
  process.argv[0] = 'coffee';

  if (opts.output) {
    const outputBasename = path.basename(opts.output);
    if (Array.from(outputBasename).includes('.')
       && !['.', '..'].includes(outputBasename)
       && !helpers.ends(opts.output, path.sep)) {
      // An output filename was specified, e.g. `/dist/scripts.js`.
      opts.outputFilename = outputBasename;
      opts.outputPath = path.resolve(path.dirname(opts.output));
    } else {
      // An output path was specified, e.g. `/dist`.
      opts.outputFilename = null;
      opts.outputPath = path.resolve(opts.output);
    }
  }

  if (opts.join) {
    opts.join = path.resolve(opts.join);
    console.error(`\

The --join option is deprecated and will be removed in a future version.

If for some reason it's necessary to share local variables between files,
replace...

    $ coffee --compile --join bundle.js -- a.coffee b.coffee c.coffee

with...

    $ cat a.coffee b.coffee c.coffee | coffee --compile --stdio > bundle.js
\
`);
  }
  return (() => {
    const result = [];
    for (let source of Array.from(opts.arguments)) {
      source = path.resolve(source);
      result.push(compilePath(source, true, source));
    }
    return result;
  })();
};

var makePrelude = (requires) => requires.map((module) => {
  let match; let
    name;
  if (match = module.match(/^(.*)=(.*)$/)) {
    let full;
    [full, name, module] = match;
  }
  if (!name) { name = helpers.baseFileName(module, true, useWinPathSep); }
  return `global['${name}'] = require('${module}')`;
}).join(';');

// Compile a path, which could be a script or a directory. If a directory
// is passed, recursively compile all '.coffee', '.litcoffee', and '.coffee.md'
// extension source files in it and all subdirectories.
var compilePath = function (source, topLevel, base) {
  let err; let
    stats;
  if (Array.from(sources).includes(source)
            || watchedDirs[source]
            || (!topLevel && (notSources[source] || hidden(source)))) { return; }
  try {
    stats = fs.statSync(source);
  } catch (error) {
    err = error;
    if (err.code === 'ENOENT') {
      console.error(`File not found: ${source}`);
      process.exit(1);
    }
    throw err;
  }
  if (stats.isDirectory()) {
    let files;
    if (path.basename(source) === 'node_modules') {
      notSources[source] = true;
      return;
    }
    if (opts.run) {
      compilePath(findDirectoryIndex(source), topLevel, base);
      return;
    }
    if (opts.watch) { watchDir(source, base); }
    try {
      files = fs.readdirSync(source);
    } catch (error1) {
      err = error1;
      if (err.code === 'ENOENT') { return; } throw err;
    }
    return Array.from(files).map((file) => compilePath((path.join(source, file)), false, base));
  } if (topLevel || helpers.isCoffee(source)) {
    let code;
    sources.push(source);
    sourceCode.push(null);
    delete notSources[source];
    if (opts.watch) { watch(source, base); }
    try {
      code = fs.readFileSync(source);
    } catch (error2) {
      err = error2;
      if (err.code === 'ENOENT') { return; } throw err;
    }
    return compileScript(source, code.toString(), base);
  }
  return notSources[source] = true;
};

var findDirectoryIndex = function (source) {
  for (const ext of Array.from(CoffeeScript.FILE_EXTENSIONS)) {
    const index = path.join(source, `index${ext}`);
    try {
      if ((fs.statSync(index)).isFile()) { return index; }
    } catch (err) {
      if (err.code !== 'ENOENT') { throw err; }
    }
  }
  console.error(`Missing index.coffee or index.litcoffee in ${source}`);
  return process.exit(1);
};

// Compile a single source script, containing the given code, according to the
// requested options. If evaluating the script directly, set `__filename`,
// `__dirname` and `module.filename` to be correct relative to the script's path.
var compileScript = function (file, input, base = null) {
  let task;
  const options = compileOptions(file, base);
  try {
    task = { file, input, options };
    CoffeeScript.emit('compile', task);
    if (opts.tokens) {
      return printTokens(CoffeeScript.tokens(task.input, task.options));
    } if (opts.nodes) {
      return printLine(CoffeeScript.nodes(task.input, task.options).toString().trim());
    } if (opts.run) {
      CoffeeScript.register();
      if (opts.prelude) { CoffeeScript.eval(opts.prelude, task.options); }
      return CoffeeScript.run(task.input, task.options);
    } if (opts.join && (task.file !== opts.join)) {
      if (helpers.isLiterate(file)) { task.input = helpers.invertLiterate(task.input); }
      sourceCode[sources.indexOf(task.file)] = task.input;
      return compileJoin();
    }
    const compiled = CoffeeScript.compile(task.input, task.options);
    task.output = compiled;
    if (opts.map) {
      task.output = compiled.js;
      task.sourceMap = compiled.v3SourceMap;
    }

    CoffeeScript.emit('success', task);
    if (opts.print) {
      return printLine(task.output.trim());
    } if (opts.compile || opts.map) {
      const saveTo = opts.outputFilename && (sources.length === 1)
        ? path.join(opts.outputPath, opts.outputFilename)
        : options.jsPath;
      return writeJs(base, task.file, task.output, saveTo, task.sourceMap);
    }
  } catch (err) {
    CoffeeScript.emit('failure', err, task);
    if (CoffeeScript.listeners('failure').length) { return; }
    const message = (err != null ? err.stack : undefined) || `${err}`;
    if (opts.watch) {
      return printLine(`${message}\x07`);
    }
    printWarn(message);
    return process.exit(1);
  }
};

// Attach the appropriate listeners to compile scripts incoming over **stdin**,
// and write them back to **stdout**.
var compileStdio = function () {
  if (opts.map) {
    console.error('--stdio and --map cannot be used together');
    process.exit(1);
  }
  const buffers = [];
  const stdin = process.openStdin();
  stdin.on('data', (buffer) => {
    if (buffer) { return buffers.push(buffer); }
  });
  return stdin.on('end', () => compileScript(null, Buffer.concat(buffers).toString()));
};

// If all of the source files are done being read, concatenate and compile
// them together.
let joinTimeout = null;
var compileJoin = function () {
  if (!opts.join) { return; }
  if (!sourceCode.some((code) => code === null)) {
    clearTimeout(joinTimeout);
    return joinTimeout = wait(100, () => compileScript(opts.join, sourceCode.join('\n'), opts.join));
  }
};

// Watch a source CoffeeScript file using `fs.watch`, recompiling it every
// time the file is updated. May be used in combination with other options,
// such as `--print`.
var watch = function (source, base) {
  let watcher = null;
  let prevStats = null;
  let compileTimeout = null;

  const watchErr = function (err) {
    if (err.code !== 'ENOENT') { throw err; }
    if (!Array.from(sources).includes(source)) { return; }
    try {
      rewatch();
      return compile();
    } catch (error1) {
      removeSource(source, base);
      return compileJoin();
    }
  };

  var compile = function () {
    clearTimeout(compileTimeout);
    return compileTimeout = wait(25, () => fs.stat(source, (err, stats) => {
      if (err) { return watchErr(err); }
      if (prevStats
                          && (stats.size === prevStats.size)
                          && (stats.mtime.getTime() === prevStats.mtime.getTime())) { return rewatch(); }
      prevStats = stats;
      return fs.readFile(source, (err, code) => {
        if (err) { return watchErr(err); }
        compileScript(source, code.toString(), base);
        return rewatch();
      });
    }));
  };

  const startWatcher = () => watcher = fs.watch(source)
    .on('change', compile)
    .on('error', (err) => {
      if (err.code !== 'EPERM') { throw err; }
      return removeSource(source, base);
    });

  var rewatch = function () {
    if (watcher != null) {
      watcher.close();
    }
    return startWatcher();
  };

  try {
    return startWatcher();
  } catch (error) {
    const err = error;
    return watchErr(err);
  }
};

// Watch a directory of files for new additions.
var watchDir = function (source, base) {
  let watcher = null;
  let readdirTimeout = null;

  const startWatcher = () => watcher = fs.watch(source)
    .on('error', (err) => {
      if (err.code !== 'EPERM') { throw err; }
      return stopWatcher();
    }).on('change', () => {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, () => {
        let files;
        try {
          files = fs.readdirSync(source);
        } catch (err) {
          if (err.code !== 'ENOENT') { throw err; }
          return stopWatcher();
        }
        return Array.from(files).map((file) => compilePath((path.join(source, file)), false, base));
      });
    });

  var stopWatcher = function () {
    watcher.close();
    return removeSourceDir(source, base);
  };

  watchedDirs[source] = true;
  try {
    return startWatcher();
  } catch (error) {
    const err = error;
    if (err.code !== 'ENOENT') { throw err; }
  }
};

var removeSourceDir = function (source, base) {
  delete watchedDirs[source];
  let sourcesChanged = false;
  for (const file of Array.from(sources)) {
    if (source === path.dirname(file)) {
      removeSource(file, base);
      sourcesChanged = true;
    }
  }
  if (sourcesChanged) { return compileJoin(); }
};

// Remove a file from our source list, and source code cache. Optionally remove
// the compiled JS version as well.
var removeSource = function (source, base) {
  const index = sources.indexOf(source);
  sources.splice(index, 1);
  sourceCode.splice(index, 1);
  if (!opts.join) {
    silentUnlink(outputPath(source, base));
    silentUnlink(outputPath(source, base, '.js.map'));
    return timeLog(`removed ${source}`);
  }
};

var silentUnlink = function (path) {
  try {
    return fs.unlinkSync(path);
  } catch (err) {
    if (!['ENOENT', 'EPERM'].includes(err.code)) { throw err; }
  }
};

// Get the corresponding output JavaScript path for a source file.
var outputPath = function (source, base, extension) {
  if (extension == null) { extension = '.js'; }
  const basename = helpers.baseFileName(source, true, useWinPathSep);
  const srcDir = path.dirname(source);
  const dir = !opts.outputPath
    ? srcDir
    : source === base
      ? opts.outputPath
      : path.join(opts.outputPath, path.relative(base, srcDir));
  return path.join(dir, basename + extension);
};

// Recursively mkdir, like `mkdir -p`.
const mkdirp = function (dir, fn) {
  let mkdirs;
  const mode = 0o777 & ~process.umask();

  return (mkdirs = (p, fn) => fs.exists(p, (exists) => {
    if (exists) {
      return fn();
    }
    return mkdirs(path.dirname(p), () => fs.mkdir(p, mode, (err) => {
      if (err) { return fn(err); }
      return fn();
    }));
  }))(dir, fn);
};

// Write out a JavaScript source file with the compiled code. By default, files
// are written out in `cwd` as `.js` files with the same name, but the output
// directory can be customized with `--output`.
//
// If `generatedSourceMap` is provided, this will write a `.js.map` file into the
// same directory as the `.js` file.
var writeJs = function (base, sourcePath, js, jsPath, generatedSourceMap = null) {
  const sourceMapPath = `${jsPath}.map`;
  const jsDir = path.dirname(jsPath);
  const compile = function () {
    if (opts.compile) {
      if (js.length <= 0) { js = ' '; }
      if (generatedSourceMap) { js = `${js}\n//# sourceMappingURL=${helpers.baseFileName(sourceMapPath, false, useWinPathSep)}\n`; }
      fs.writeFile(jsPath, js, (err) => {
        if (err) {
          printLine(err.message);
          return process.exit(1);
        } if (opts.compile && opts.watch) {
          return timeLog(`compiled ${sourcePath}`);
        }
      });
    }
    if (generatedSourceMap) {
      return fs.writeFile(sourceMapPath, generatedSourceMap, (err) => {
        if (err) {
          printLine(`Could not write source map: ${err.message}`);
          return process.exit(1);
        }
      });
    }
  };
  return fs.exists(jsDir, (itExists) => {
    if (itExists) { return compile(); } return mkdirp(jsDir, compile);
  });
};

// Convenience for cleaner setTimeouts.
var wait = (milliseconds, func) => setTimeout(func, milliseconds);

// When watching scripts, it's useful to log changes with the timestamp.
var timeLog = (message) => console.log(`${(new Date()).toLocaleTimeString()} - ${message}`);

// Pretty-print a stream of tokens, sans location data.
var printTokens = function (tokens) {
  const strings = (() => {
    const result = [];
    for (const token of Array.from(tokens)) {
      const tag = token[0];
      const value = token[1].toString().replace(/\n/, '\\n');
      result.push(`[${tag} ${value}]`);
    }
    return result;
  })();
  return printLine(strings.join(' '));
};

// Use the [OptionParser module](optparse.html) to extract all options from
// `process.argv` that are specified in `SWITCHES`.
var parseOptions = function () {
  const o = (opts = optionParser.parse(process.argv.slice(2)));
  if (!o.compile) { o.compile = !!o.output; }
  o.run = !(o.compile || o.print || o.map);
  return o.print = !!(o.print || (o.eval || (o.stdio && o.compile)));
};

// The compile-time options to pass to the CoffeeScript compiler.
var compileOptions = function (filename, base) {
  if (opts.transpile) {
    // The user has requested that the CoffeeScript compiler also transpile
    // via Babel. We don’t include Babel as a dependency because we want to
    // avoid dependencies in general, and most users probably won’t be relying
    // on us to transpile for them; we assume most users will probably either
    // run CoffeeScript’s output without transpilation (modern Node or evergreen
    // browsers) or use a proper build chain like Gulp or Webpack.
    try {
      require('babel-core');
    } catch (error) {
      // Give appropriate instructions depending on whether `coffee` was run
      // locally or globally.
      if (require.resolve('.').indexOf(process.cwd()) === 0) {
        console.error(`\
To use --transpile, you must have babel-core installed:
  npm install --save-dev babel-core
And you must save options to configure Babel in one of the places it looks to find its options.
See http://coffeescript.org/#transpilation\
`);
      } else {
        console.error(`\
To use --transpile with globally-installed CoffeeScript, you must have babel-core installed globally:
  npm install --global babel-core
And you must save options to configure Babel in one of the places it looks to find its options, relative to the file being compiled or to the current folder.
See http://coffeescript.org/#transpilation\
`);
      }
      process.exit(1);
    }

    if (typeof opts.transpile !== 'object') { opts.transpile = {}; }

    // Pass a reference to Babel into the compiler, so that the transpile option
    // is available for the CLI. We need to do this so that tools like Webpack
    // can `require('coffeescript')` and build correctly, without trying to
    // require Babel.
    opts.transpile.transpile = CoffeeScript.transpile;

    // Babel searches for its options (a `.babelrc` file, a `.babelrc.js` file,
    // a `package.json` file with a `babel` key, etc.) relative to the path
    // given to it in its `filename` option. Make sure we have a path to pass
    // along.
    if (!opts.transpile.filename) {
      opts.transpile.filename = filename || path.resolve(base || process.cwd(), '<anonymous>');
    }
  } else {
    opts.transpile = false;
  }

  let answer = {
    filename,
    literate: opts.literate || helpers.isLiterate(filename),
    bare: opts.bare,
    header: opts.compile && !opts['no-header'],
    transpile: opts.transpile,
    sourceMap: opts.map,
    inlineMap: opts['inline-map'],
  };

  if (filename) {
    if (base) {
      const cwd = process.cwd();
      const jsPath = outputPath(filename, base);
      const jsDir = path.dirname(jsPath);
      answer = helpers.merge(answer, {
        jsPath,
        sourceRoot: path.relative(jsDir, cwd),
        sourceFiles: [path.relative(cwd, filename)],
        generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep),
      });
    } else {
      answer = helpers.merge(answer, {
        sourceRoot: '',
        sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],
        generatedFile: `${helpers.baseFileName(filename, true, useWinPathSep)}.js`,
      });
    }
  }
  return answer;
};

// Start up a new Node.js instance with the arguments in `--nodejs` passed to
// the `node` binary, preserving the other options.
var forkNode = function () {
  const nodeArgs = opts.nodejs.split(/\s+/);
  const args = process.argv.slice(1);
  args.splice(args.indexOf('--nodejs'), 2);
  const p = spawn(process.execPath, nodeArgs.concat(args), {
    cwd: process.cwd(),
    env: process.env,
    stdio: [0, 1, 2],
  });
  for (const signal of ['SIGINT', 'SIGTERM']) {
    process.on(signal, (((signal) => () => p.kill(signal)))(signal));
  }
  return p.on('exit', (code) => process.exit(code));
};

// Print the `--help` usage message and exit. Deprecated switches are not
// shown.
var usage = () => printLine(optionParser.help());

// Print the `--version` message and exit.
var version = () => printLine(`CoffeeScript version ${CoffeeScript.VERSION}`);
